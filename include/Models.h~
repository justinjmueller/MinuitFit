#ifndef MODELS_H
#define MODELS_H

//C++ includes.
#include <memory>
#include <vector>

//ROOT includes.
#include "TMinuit.h"
#include "TF2.h"

//Custom Includes
#include "SettingsObject.h"
#include "FunctionObject.h"

namespace NESTModel
{
  class BaseModel
  {
  public:
    BaseModel(unsigned int id = 0);
    double operator()(double* x, double* p);
    double Derivative(double* x, double* p);
    bool Minimize();
    void PrintResults();
    void DrawGraphs();
    void SetDefaultField(double Field);
    std::vector<double> GetParameters();
    std::vector<double> GetParameterErrors();
    std::vector<double> DataX;
    std::vector<double> DataXErrLow;
    std::vector<double> DataXErrHigh;
    std::vector<double> DataY;
    std::vector<double> DataZ;
    std::vector<double> DataZErrLow;
    std::vector<double> DataZErrHigh;
    
  private:
    unsigned int ID;
    virtual std::string SetModelType() {ModelType = ""};
    std::string ModelType;
    unsigned int NData;
    unsigned int NPar;
    double DefaultField;
    bool Success(false);
    std::shared_ptr<TMinuit> MinuitMinimizer;
    std::vector<double> InitialVect;
    std::vector<double> StepVect;
    std::vector<double> LimitsLow;
    std::vector<double> LimitsHigh;
    std::vector<double> Parameters;
    std::vector<double> ParameterErrors;
    SettingsObject Settings;
    std::shared_ptr<FunctionObject> FuncObject;
    std::shared_ptr<TF2> ModelFunction;
    std::shared_ptr<TF2> ModelDerivative;
  };

  BaseModel* GlobalModel;

  void Chi2(int& npar, double *x, double &result, double *par, int flag)
  {
    double WRSS(0);
    double Difference(0);
    double xData[2];
    for(unsigned int datum(0); datum < LightModel->DataX.size(); ++datum)
    {
      xData[0] = GlobablModel->DataX.at(datum);
      xData[1] = GlobalModel->DataY.at(datum);
      Difference = GlobalModel->DataZ.at(datum) - (*GlobalModel)(xData, par);
      if(Difference < 0) WRSS += (TMath::Power(Difference, 2.0)) / ( TMath::Power(GlobalModel->DataZErrHigh.at(datum),2.0) + TMath::Power( (0.5*(GlobalModel->DataXErrLow.at(datum) + GlobalModel->DataXErrHigh.at(datum))*(GlobalModel->Derivative(x, par)) ), 2.0) );
      else WRSS += (TMath::Power(Difference, 2.0)) / ( TMath::Power(GlobalModel->DataZErrLow.at(datum),2.0) + TMath::Power( (0.5*(GlobalModel->DataXErrLow.at(datum) + GlobalModel->DataXErrHigh.at(datum))*(GlobalModel->Derivative(x, par)) ), 2.0) );
    }
    result = WRSS;
  }
}
